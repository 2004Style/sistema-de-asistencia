services:
  # ============================================
  # PostgreSQL Database (OPCIONAL)
  # ============================================
  # Descomenta esta sección para usar PostgreSQL localmente
  # En producción, puedes usar un servidor PostgreSQL externo
  # postgres:
  #   image: postgres:15-alpine
  #   container_name: sistema-asistencia-db
  #   hostname: postgres
  #   environment:
  #     POSTGRES_DB: ${DB_NAME:-asistencia_db}
  #     POSTGRES_USER: ${DB_USER:-asistencia}
  #     POSTGRES_PASSWORD: ${DB_PASSWORD:-asistencia123}
  #   volumes:
  #     - postgres_data:/var/lib/postgresql/data
  #   ports:
  #     - "${DB_PORT:-5432}:5432"
  #   networks:
  #     - sistema-asistencia-network
  #   restart: unless-stopped
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-asistencia}"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5

  # ============================================
  # API FastAPI (Backend)
  # ============================================
  api:
    build:
      context: ./server
      dockerfile: Dockerfile
    container_name: sistema-asistencia-api
    hostname: api
    
    # Cargar archivo .env del servidor
    env_file:
      - ./server/.env
    
    environment:
      - DEBUG=false
      - ENVIRONMENT=production
      # DATABASE_URL se carga desde server/.env
      # Si usas postgres local, descomenta la sección postgres arriba
      # y configura: DATABASE_URL=postgresql://asistencia:asistencia123@postgres:5432/asistencia_db
    
    ports:
      # Puerto del API (accesible desde nginx)
      - "8000:8000"
    
    volumes:
      # Volúmenes para datos persistentes
      - api_public:/app/public
      - api_recognize:/app/recognize/data
    
    networks:
      - sistema-asistencia-network
    
    restart: unless-stopped
    
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health').read()"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    
    # Esperar a postgres si está habilitado
    # depends_on:
    #   postgres:
    #     condition: service_healthy

  # ============================================
  # Next.js Client (Frontend)
  # ============================================
  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: sistema-asistencia-client
    hostname: client
    
    # Cargar variables desde .env del cliente
    # Todas las variables NEXT_PUBLIC_* deben estar en client/.env
    env_file:
      - ./client/.env
    
    environment:
      - NODE_ENV=production
      - NEXT_TELEMETRY_DISABLED=1
      # NEXT_PUBLIC_URL_BACKEND se carga desde client/.env
    
    ports:
      # Puerto del cliente (accesible desde nginx)
      - "3000:3000"
    
    networks:
      - sistema-asistencia-network
    
    restart: unless-stopped
    
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3000', (r) => {if (r.statusCode !== 200 && r.statusCode !== 304) process.exit(1)}).on('error', () => process.exit(1))\""]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s

  # ============================================
  # Nginx - Reverse Proxy (PUERTA DE ENTRADA)
  # ============================================
  nginx:
    image: nginx:alpine
    container_name: sistema-asistencia-nginx
    hostname: nginx
    
    # ÚNICO acceso público al exterior
    ports:
      - "80:80"
      - "443:443"
    
    volumes:
      # Configuración de nginx
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      # Certificados SSL (opcionales, pero recomendados)
      - ./certs:/etc/nginx/certs:ro
    
    depends_on:
      - api
      - client
    
    networks:
      - sistema-asistencia-network
    
    restart: unless-stopped
    
    healthcheck:
      test: ["CMD-SHELL", "nc -z localhost 80 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s

# ============================================
# VOLUMES PERSISTENTES
# ============================================
volumes:
  api_public:
    driver: local
  api_recognize:
    driver: local
  # postgres_data:  # Descomenta si usas postgres local
  #   driver: local

# ============================================
# NETWORK INTERNA
# ============================================
networks:
  sistema-asistencia-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# ============================================
# NOTAS IMPORTANTES
# ============================================
# 1. PostgreSQL es OPCIONAL:
#    - Para producción: usa servidor externo y configura DATABASE_URL en .env
#    - Para desarrollo: descomenta la sección postgres
#
# 2. Nginx es el ÚNICO acceso público (puertos 80/443)
#    - Cliente (Next.js) accesible en: http://localhost/
#    - API accesible en: http://localhost/api/
#    - WebSockets en: ws://localhost/api/socket.io/
#
# 3. Comunicación interna entre contenedores por hostname:
#    - api:8000 (desde nginx)
#    - client:3000 (desde nginx)
#    - postgres:5432 (desde api, si está habilitado)
#
# 4. ESP32 se conecta externamente:
#    - API en: ws://tudominio/api/socket.io/
#    - Nginx expone puertos 80/443 públicamente
#
# 5. Variables de entorno (.env):
#    - DATABASE_URL (si usas postgres externo o local)
#    - JWT_SECRET
#    - MAIL_USERNAME, MAIL_PASSWORD
#    - AWS credentials (si usas reconocimiento facial)
#    - etc.
